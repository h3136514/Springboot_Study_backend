# 5장. 데이터베이스 조작이 편해지는 ORM

## 5.1 데이터베이스란?
데이터를 효율적으로 보관하고 꺼내볼 수 있는 곳, 데이터의 안전한 사용과 관리가 가능
### 5.1.1 데이터베이스 관리자, DBMS
* __DBMS__: 데이터베이스를 관리하기 위한 소프트웨어 (MySQL, 오라클 등)   
* __관계형 DBMS(RDBMS)__: 테이블 형태로 이루어진 데이터 저장소 (MySQL, H2)   
* __H2__:
    - 자바로 작성된 RDBMS. 스프링 부트가 지원하는 인메모리 관계형 데이터베이스
    - 애플리케이션 자체 내부에 데이터 저장 → 애플리케이션 재실행 시 데이터 초기화
    - 테스트 용도로 많이 사용 (실제 서비스에는 MySQL)

## 5.2 ORM이란?
자바의 객체와 데이터베이스를 연결하는 프로그래밍 기법
* 장점:
    - SQL 없이도 자바 언어로만 데이터베이스에 접근 가능
    - 객체지향적으로 코드 작성 → 비즈니스 로직에만 집중 가능
    - 데이터베이스 시스템에 대한 종속성↓
    - 매핑하는 정보 명확 → ERD 의존도↓, 유지보수 유리
* 단점:
    - 프로젝트의 복잡성이 커질수록 사용 난이도 커짐
    - 복잡하고 무거운 쿼리 해결 불가능

## 5.3 JPA와 하이버네이트?
* __JPA (JAVA Persistence API)__: 자바에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스, 자바 코드를 알아서 쿼리로 변경해줌
* __하이버네이트__: JPA의 구현체, 자바용 ORM 프레임워크. 내부적으로는 JDBC API 사용
### 5.3.1 엔티티 매니저란?
* __엔티티__: 데이터베이스의 테이블과 직접 연결된, 쿼리를 실행하는 객체. 영속성을 가짐
* __엔티티 매니저__: 엔티티를 관리하며 조회, 삭제, 수정, 생성함
* __엔티티 매니저 팩토리__: 엔티티 매니저를 생성
* 스프링 부트의 경우:
    - 내부에서 엔티티 매니저 팩토리를 하나만 생성해서 관리
    - `@PersistenceContext` / `@Autowired`를 사용해 엔티티 매니저 사용
    - 동시성 문제 방지를 위해 프록시(가짜) 엔티티 매니저를 사용 (실제 엔티티 매니저와 연결)
        + 💡 동시성 문제: 2개 이상의 스레드가 한 객체를 동시에 제어할 때 발생
### 5.3.2 영속성 컨텍스트란?
엔티티를 관리하는 가상의 공간 → 데이터, 엔티티 사용이 편해짐
* __1차 캐시__:
    - 키: `@Id`가 달린 기본키 식별자, 값: 엔티티
    - 엔티티 조회 → 1차 캐시 조회, 값이 있으면 반환 → 없으면 데이터베이스 조회, 1차 캐시에 저장 후 반환
    - 데이터 빠르게 조회 가능
* __쓰기 지연__: 트랜잭션을 커밋하기 전까지 데이터베이스에 쿼리를 모았다가, 커밋하면 모아둔 쿼리 한번에 실행
* __변경 감지__: 트랜잭션 커밋 시 1차 캐시의 엔티티 값과 현재 엔티티 값을 비교해 변경 사항을 데이터베이스에 자동 반영
* __지연 로딩__: 쿼리로 요청한 데이터를 애플리케이션에 바로 로딩하지 않고, 필요할 때 조회

→ 데이터베이스의 접근 최소화, 성능↑
### 5.3.3 엔티티의 상태
* __비영속__: 영속성 컨텍스트와 관계 X (엔티티 생성)
* __관리__: 영속성 컨텍스트가 관리 (`persist()` 메서드)
* __분리__: 영속성 컨텍스트가 관리 X (`detach()` 메서드)
* __삭제__: (`remove()` 메서드)


## 5.4 스프링 데이터와 스프링 데이터 JPA
### 5.4.1 스프링 데이터 JPA란?
* __스프링 데이터__:
    - 데이터베이스 기능을 클래스 레벨에서 추상화 → 비즈니스 로직에 집중 가능
    - CRUD, 페이징 처리, 메서드 이름으로 쿼리 자동 생성 등의 기능 제공
* __스프링 데이터 JPA__:
    - JPA를 쓰기 편하게 만들어놓은 모듈
    - 스프링 데이터의 PagingAndSortingRepository 인터페이스를 상속받아 JpaRepository 인터페이스 만듦
    - `public interface (repository이름) extends JpaRepository<(엔티티 이름), (엔티티 기본키 타입)> {}`   
      → 엔티티에 기본 CRUD 메서드 사용 가능


## ✔ 어노테이션
* __`@Entity`__: 객체를 JPA가 관리하는 엔티티로 지정 (클래스-데이터베이스 테이블 매핑)
* __`@NoArgsConstructor`__: 기본 생성자, public 또는 protected로 접근 제어자 설정 가능
    - `@NoArgsConstructor(access = AccessLevel.PROTECTED)`
* __`@Id`__: 테이블의 기본키 지정
* __`@GeneratedValue`__: 기본키 생성 방식 (`@GeneratedValue(strategy = GenerationType.(방식))`)
    - __AUTO__: 선택한 데이터베이스 방언(dialect)에 따라 방식을 자동으로 선택 (기본값)
        + ex) MySQL – IDENTITY, H2 - SEQUENCE …
    - __IDENTITY__: 기본키 생성을 데이터베이스에 위임
    - __SEQUENCE__: 데이터베이스 시퀀스를 사용해서 기본키 할당 (오라클에서 주로 사용), 클래스 위에 __`@SequenceGenerator()`__ 선언
        + name: 식별자 생성기 이름
            + `@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = “name”)`
        + sequenceName: 데이터베이스의 시퀀스 이름
        + initialValue: DDL 생성 시 처음 시작하는 수 (기본값 1)
        + allocationSize: 시퀀스를 한 번 호출할 때마다 증가하는 수 (기본값 50)
        + 등등…
    - __TABLE__: 키 생성 전용 테이블 사용 (모든 데이터베이스에 적용 가능, 성능 떨어짐), 클래스 위에 __`@TableGenerator()`__ 선언
        + name: 식별자 생성기 이름
        + table: 키 생성 테이블명
        + pkColumnValue: 키로 사용할 이름
        + initialValue: DDL 생성 시 처음 시작하는 수 (기본값 0)
        + allocationSize: 시퀀스 한 번 호출에 증가하는 수 (기본값 50)
        + 등등…
<br></br>
    > ❓ __IDENTITY와 SEQUENCE의 차이점__:
    > + IDENTITY: 엔티티를 데이터베이스에 저장한 후에 식별자를 조회해 할당함
    > + SEQUENCE: DB 시퀀스(식별자)를 먼저 조회한 후 엔티티에 할당하고 엔티티를 저장

    > ❓ __SEQUENCE, TABLE의 allocationSize 기본값이 50인 이유__:
    > + 시퀀스 값을 한 번에 많이 선점해서 JPA의 접근 횟수를 줄이고, 여러 JVM이 동시에 동작해도 기본키 값이 충돌하지 않음

* __`@Column`__: 데이터베이스 컬럼과 필드 매핑
    - name: 필드와 매핑할 컬럼 이름 (설정하지 않으면 필드 이름으로 지정)
    - nullable: 컬럼의 null 허용 여부 (설정하지 않으면 true)
    - unique: 컬럼의 유일한 값 여부 (설정하지 않으면 false)
    - columnDefinition: DB 컬럼 정보 설정 가능 (ex. `@Column(columnDefinition = "varchar(100) default 'EMPTY'"`)
