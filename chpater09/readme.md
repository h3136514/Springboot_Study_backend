# 9장. JWT로 로그인/로그아웃 구현하기
## 9.1 사전지식: 토큰 기반 인증
### 9.1.1 토큰 기반 인증이란?
__토큰__: 서버에서 클라이언트를 구분하기 위한 유일한 값  
서버가 토큰을 생성해서 클라이언트에게 제공 → 클라이언트는 여러 요청을 저장한 토큰과 함께 신청 → 서버는 토큰만 보고 유효한 사용자인지 검증  

- 무상태성: 토큰의 생성과 유지(상태 관리)는 클라이언트에서 이루어지므로 서버는 완전한 무상태(stateless)로 효율적인 검증이 가능
- 확장성: 서버를 확장할 때 상태 관리를 신겅 쓸 필요가 없어 서버 확장도 용이함. 토큰을 가지는 주체가 클라이언트이기 때문에 여러 서버에 요청을 보낼 수 있음
- 무결성: 토큰을 발급한 이후에는 토큰 정보를 변경할 수 없음. 변경되면 유효하지 않은 토큰이 됨

### 9.1.2 JWT
❓ __JWT(Json Web Token)__: Json 객체에 인증에 필요한 정보들을 담은 후 비밀키로 서명한 토큰 (인터넷 표준 인증 방식)  
JWT를 이용한 인증: HTTP 요청 헤더 중 Authorization 키값에 Bearer + JWT 토큰값을 넣어 보내야 함  
> HTTP의 connectionless, stateless 특성 때문에 매 요청마다 JWT를 보내는 것


JWT의 구조: 헤더.내용.서명  

- __헤더(Header)__: 토큰의 타입과 해싱 알고리즘을 지정하는 정보
    + ```java
      {
        "typ": "JWT",
        "alg": "HS256"
      }
      ```
    + HS256: 비밀키
    + RS256: 공개키
    > 🔑 S256: 데이터 무결성을 위해 사용되는 암호화 해쉬 알고리즘(SHA256)을 의미. 2^256가지의 경우의 수
    > - HS256: 대칭키 암호화 알고리즘 (같은 키로 암호화/복호화, 비밀키를 알고 있는 서버만 유효성 검증 및 복호화 가능)
    > - RS256: 비대칭키 암호화 알고리즘 (다른 키로 암호화/ 복호화, 비밀키를 몰라도 공개키로 유효성 검증 및 복호화 가능)
- __내용(Payload)__: 토큰과 관련된 정보
    + 클레임: 내용의 한 덩어리. 키값의 한쌍으로 이루어짐
        * 등록된 클레임: 토큰에 대한 정보를 담는 데 사용
            - |이름|설명|
              |--|--|
              |iss|토큰 발급자(issuer)|
              |sub|토큰 제목(subject)|
              |aud|토큰 대상자(audience)|
              |exp|토큰의 만료 시간(expiration)|
              |nbf|토큰이 활성되기까지의 날짜(not before)|
              |iat|토큰의 발급 시간(issued at)|
              |jti|JWT의 고유 식별자|
        * 공개 클레임: 공개되어도 상관없는 클레임. 이름은 충돌하면 안되며 보통 URI로 지음
        * 비공개 클레임: 공개되면 안 되는 클레임. 클라이언트-서버 통신에 사용
        * ```java
          "iss": "ajufresh@gmail.com",  // 등록된 클레임
          "iat": 1622370878,  // 등록된 클레임
          "https://shinsunyoung.com/jwt_claims/is_admin": true,  // 공개 클레임
          "email": "ajufresh@gmail.com"  // 비공개 클레임 (등록된 클레임도 공개 클레임도 아님)
          ```
- __서명(Signature)__: 해당 토큰이 조작되었거나 변경되지 않았음을 확인하는 용도로 사용. 헤더와 내용의 인코딩값을 합친 후, 헤더의 알고리즘과 주어진 비밀키를 사용해 해시값을 생성(암호화)  
<br>

__리프레시 토큰__: 액세스 토큰이 만료되었을 때 새로운 액세스 토큰을 발급하기 위한 토큰  
- 액세스 토큰의 유효 기간은 짧게, 리프레시 토큰의 유효 기간은 길게 설정하면 더 안전해진다  
- 서버에서 생성되어 클라이언트와 DB에도 저장 → 액세스 토큰 만료 시 클라이언트가 리프레시 토큰과 함께 새 액세스 토큰의 발급을 요청함 → 서버는 리프레시 토큰이 유효한지+DB의 리프레시 토큰과 같은지 확인한 후 새 액세스 토큰을 생성해 응답  
> ❓ 리프레시 토큰이 탈취되는 경우
> - 새 액세스 토큰을 요청할 때 리프레시 토큰과 기존의 액세스 토큰도 함께 보내서 그 쌍을 검증하는 방법 사용


> ⏰ 다른 방법: __Sliding Session__
> - 유저가 특정 행동을 할 때(글쓰기, 결제 등) 만료시간을 늘린 새 JWT를 제공
> - Sliding session으로 연장시켜줄 수 없는 상황, 너무 오래 연장시킨 상황 등이 생기기도 해서 리프레시 토큰이 가장 많이 사용됨
<br>

__JWT의 장점__

- 토큰 자체가 인증된 정보이기 때문에 별도의 저장소가 필요하지 않으며 HTTP의 stateless 특성 유지할 수 있음
- 토큰이 만료되었을 때만 저장소에 접근하기 때문에 세션보다 접근 횟수가 적음
- Signature로 인해 비교적 안전함
- HTTP 헤더를 통해 간단하게 전송되므로 네트워크 부하가 적음
- 다른 서비스에도 이용할 수 있음 (확장성)

__단점__

- 보안 문제로 리프레시 토큰을 도입하면 이를 저장하기 위한 별도의 저장소가 필요함 (stateless 위반)
- 거의 모든 요청에 토큰이 포함되므로 트래픽 크기에 영향을 미칠 수 있음
- 토큰의 크기가 커지면 네트워크 부하가 커짐
- 내용(payload)는 암호화된 게 아니라 탈취 당하면 정보가 유출될 수 있음 → 내용에는 민감한 정보 저장 X
- ❗ 토큰이 탈취당하면 만료될 때까지 대처가 불가능함 (서버가 관리할 수 X) → 만료시간을 짧게
